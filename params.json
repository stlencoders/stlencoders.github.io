{"name":"stlencoders","tagline":"Generic Base2/16/32/64 Encoding Algorithms for C++","body":"**stlencoders** is a C++ implementation of the Base16, Base32 and Base64 encoding schemes as defined in [RFC 4648](http://www.apps.ietf.org/rfc/rfc4648.html).  Base2, i.e. binary encoding, is also supported.\r\n\r\nIn a nutshell, the **stlencoders** library\r\n\r\n  * implements encoding and decoding operations as _generic algorithms_ that operate on STL-style iterators\r\n  * supports different encoding alphabets using custom _traits classes_\r\n  * supports wide-character encodings, at least on platforms where [the characters from the portable C execution set correspond to their wide character equivalents by zero extension](http://unicode.org/uni2book/ch05.pdf)\r\n  * comes with full documentation and an extensive unit test suite\r\n  * is implemented as a _header-only_ library, i.e. requires no separately-compiled library binaries or special treatment when linking; this also means that installation is as simple as copying the header files to a location of your convenience\r\n  * is designed to be highly portable and has been tested on Windows and Linux with a number of different compilers\r\n  * provides reasonable performance that matches most (if not all) alternative implementations\r\n\r\n### Examples\r\n\r\nA simple program that Base64-encodes standard input to standard output can be essentially written as:\r\n\r\n```\r\n#include <stlencoders/base64.hpp>\r\n\r\n#include <iostream>\r\n#include <iterator>\r\n\r\nint main()\r\n{\r\n    std::istreambuf_iterator<char> in(std::cin);\r\n    std::istreambuf_iterator<char> end;\r\n    std::ostreambuf_iterator<char> out(std::cout);\r\n\r\n    stlencoders::base64<char>::encode(in, end, out);\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nTo produce MIME-compliant output, i.e. limit the line length of encoded data to 76 characters with CRLF as line delimiter, use an output iterator adaptor such as `stlencoders::line_wrapper`:\r\n\r\n```\r\nstlencoders::base64<char>::encode(in, end, stlencoders::line_wrapper(out, 76, \"\\r\\n\"));\r\n```\r\n\r\nTo use a different encoding alphabet, such as the _base64url_ scheme, which uses the characters '-' and '_' instead of '+' and '/', provide an appropriate traits class:\r\n\r\n```\r\nstlencoders::base64<char, stlencoders::base64url_traits<char> >::encode(in, end, out);\r\n```\r\n\r\nWhen decoding, a _predicate_ can be specified to indicate which non-alphabet characters should be ignored. To skip all whitespace in a locale-aware manner, one can use\r\n\r\n```\r\nstlencoders::base64<char>::decode(in, end, out, std::bind(std::isspace<char>, _1, std::locale()));\r\n```\r\n\r\nOf course, **stlencoders** can work with other container types, too. Even wide-character strings are supported:\r\n\r\n```\r\nstd::wstring s(L\"Zm9vYmFy\");\r\nstd::vector<std::uint8_t> v;\r\n\r\nstlencoders::base64<wchar_t>::decode(s.begin(), s.end(), std::back_inserter(v));\r\n```\r\n\r\n### Credits\r\n\r\n**stlencoders** was inspired by Nick Galbreath's excellent [stringencoders](http://code.google.com/p/stringencoders/) library.  If you strive for maximum performance, or happen to code in plain C, check it out!\r\n","google":"UA-46450872-1","note":"Don't delete this file! It's used internally to help with page regeneration."}